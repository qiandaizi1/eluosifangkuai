<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ê±™ÂÜõ‰∏ìÁî®Áâà‰øÑÁΩóÊñØÊñπÂùó</title>
    <style>
        :root {
            --bg-color: #110303;
            --panel-bg: rgba(30, 5, 5, 0.95);
            --neon-border: #ffd700;
        }
        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Helvetica Neue', Arial, 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        
        body.nuke-flash {
            animation: flash 0.4s ease-out;
        }
        @keyframes flash {
            0% { background-color: #fff; }
            40% { background-color: #ff0000; }
            100% { background-color: var(--bg-color); }
        }

        h1 {
            font-size: 1.6rem;
            margin: 15px 0 10px 0;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ffd700;
            color: #ffd700;
            letter-spacing: 2px;
        }

        #main-wrapper {
            display: flex;
            flex-direction: row;
            gap: 15px;
            padding: 5px;
            max-width: 100vw;
            justify-content: center;
        }

        canvas#board {
            background: rgba(15, 0, 0, 0.9);
            border: 2px solid var(--neon-border);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            border-radius: 6px;
            max-width: 60vw;
            height: auto;
            aspect-ratio: 1 / 2;
            position: relative;
        }

        #ui-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 110px;
        }

        .info-box {
            background: var(--panel-bg);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            box-shadow: inset 0 0 15px rgba(255,215,0,0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .info-box h3 {
            margin: 0 0 4px 0;
            font-size: 0.8rem;
            color: #ffaa00;
            text-transform: uppercase;
        }

        .info-box span {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
            word-break: break-all;
        }

        canvas#next-canvas {
            width: 60px;
            height: 60px;
            background: transparent;
        }

        #rage-container {
            flex-grow: 1;
            border: 2px solid #ff4444;
            background: rgba(50, 0, 0, 0.8);
            border-radius: 6px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255,0,0,0.4);
            min-height: 50px;
        }

        #rage-bar {
            background: linear-gradient(to top, #ff0000, #ffd700);
            height: 0%;
            width: 100%;
            transition: height 0.2s, width 0.2s;
        }

        #nuke-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff0000, #ff8800);
            color: #fff;
            border: 2px solid #ffd700;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            display: none;
            box-shadow: 0 0 20px #ffd700;
            animation: pulse 0.5s infinite alternate;
            z-index: 10;
        }

        .nuke-ready #nuke-btn { display: block; }
        
        #audio-toggle {
            background: transparent;
            color: #ffd700;
            border: 1px solid rgba(255, 215, 0, 0.5);
            padding: 6px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        #audio-toggle:active { background: rgba(255, 215, 0, 0.2); }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.95); }
            100% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .blessing-text {
            position: absolute;
            color: #ffd700;
            font-size: 26px;
            font-weight: 900;
            text-shadow: 2px 2px 0 #900, -2px -2px 0 #900, 2px -2px 0 #900, -2px 2px 0 #900, 0 0 20px #ff0;
            pointer-events: none;
            z-index: 1000;
            animation: floatUpWord 1s ease-out forwards;
        }

        @keyframes floatUpWord {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -20px) scale(1.1); opacity: 1; }
            80% { transform: translate(-50%, -60px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -80px) scale(1); opacity: 0; }
        }

        #mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 15px;
            width: 90vw;
            max-width: 380px;
        }

        .control-btn {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #ffd700;
            font-size: 1.6rem;
            padding: 12px 0;
            border-radius: 8px;
            text-align: center;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .control-btn:active { background: rgba(255, 215, 0, 0.3); transform: translateY(2px); box-shadow: 0 2px 3px rgba(0,0,0,0.5); }

        #btn-left { grid-column: 1; grid-row: 1; }
        #btn-rotate { grid-column: 2; grid-row: 1; }
        #btn-right { grid-column: 3; grid-row: 1; }
        #btn-down { 
            grid-column: 2; 
            grid-row: 2; 
            background: rgba(255, 0, 0, 0.15);
            border-color: rgba(255, 0, 0, 0.5);
            color: #ff4444;
        }
        #btn-down:active { background: rgba(255, 0, 0, 0.3); }

        @media (max-width: 600px) {
            #main-wrapper { flex-direction: column; align-items: center; gap: 8px; padding: 5px; }
            #ui-panel { flex-direction: row; width: 95%; justify-content: space-between; height: auto; gap: 6px; }
            .info-box { padding: 5px; flex: 1; border-radius: 4px; }
            .info-box h3 { font-size: 0.7rem; margin-bottom: 2px; }
            .info-box span { font-size: 1rem; }
            canvas#next-canvas { width: 40px; height: 40px; }
            #rage-container { flex: 1.5; height: auto; flex-direction: row; }
            #rage-bar { height: 100%; width: 0%; background: linear-gradient(to right, #ff0000, #ffd700); }
            #audio-toggle { font-size: 0.7rem; padding: 2px; display: flex; align-items: center; justify-content: center;}
            canvas#board { max-width: 95vw; height: 50vh; }
            h1 { font-size: 1.3rem; margin: 5px 0; }
        }
        @media (min-width: 601px) {
            #mobile-controls { display: none; }
        }
    </style>
</head>
<body>

<h1>üèÆ Ê±™ÂÜõ‰∏ìÁî®Áâà‰øÑÁΩóÊñØÊñπÂùó üèÆ</h1>

<div id="main-wrapper">
    <canvas id="board" width="300" height="600"></canvas>
    
    <div id="ui-panel">
        <div class="info-box">
            <h3>‰∏ã‰∏Ä‰∏™</h3>
            <canvas id="next-canvas" width="60" height="60"></canvas>
        </div>
        <div class="info-box">
            <h3>ÂæóÂàÜ</h3>
            <span id="score">0</span>
        </div>
        <div class="info-box">
            <h3>Êó∂ÈÄü</h3>
            <span id="speed-display" style="color:#ff3333;">100%</span>
        </div>
        <div id="rage-container">
            <button id="nuke-btn" onclick="triggerNuke()">ÂÖ®Â±è<br>Êö¥ÂØå</button>
            <div id="rage-bar"></div>
        </div>
        <button id="audio-toggle" onclick="toggleAudio()">üîä Èü≥‰πêÂºÄÂêØ</button>
    </div>
</div>

<div id="mobile-controls">
    <div class="control-btn" id="btn-left">‚¨ÖÔ∏è</div>
    <div class="control-btn" id="btn-rotate">üîÉ</div>
    <div class="control-btn" id="btn-right">‚û°Ô∏è</div>
    <div class="control-btn" id="btn-down">‚è¨</div>
</div>

<script>
    // --- È°∂Á∫ßÂ§öËΩ®Èü≥‰πêÂºïÊìé ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let audioEnabled = true;
    let audioUnlocked = false; 
    let bgmTimer = null;
    
    // Èü≥ÊïàÂ∫ì
    const SFX = {
        playTone: (freq, type, duration, vol, slideFreq = null) => {
            if (!audioEnabled || audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.type = type;
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if (slideFreq) {
                osc.frequency.exponentialRampToValueAtTime(slideFreq, audioCtx.currentTime + duration);
            }
            
            gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        },
        move: () => SFX.playTone(400, 'square', 0.03, 0.03),
        rotate: () => SFX.playTone(600, 'square', 0.04, 0.03),
        drop: () => SFX.playTone(100, 'sine', 0.2, 0.8, 10), // Ê≤âÈáçÁ†∏Âú∞
        clear: () => {
            SFX.playTone(880, 'square', 0.1, 0.05);
            setTimeout(() => SFX.playTone(1318, 'sine', 0.3, 0.1), 50); // Ê∏ÖËÑÜÁàÜÈáëÂ∏Å
        },
        nuke: () => {
            SFX.playTone(100, 'sawtooth', 1.0, 1.0, 10);
            setTimeout(() => SFX.playTone(80, 'square', 1.2, 0.8, 5), 100);
            setTimeout(() => SFX.playTone(150, 'sawtooth', 0.8, 0.5, 20), 200);
        }
    };

    // Â§öËΩ®ËÉåÊôØÈü≥‰πêÂ∫èÂàó (Bass, Drums, Melody)
    let step = 0;
    function startBGM() {
        if (bgmTimer) clearInterval(bgmTimer);
        bgmTimer = setInterval(() => {
            if (!audioEnabled || audioCtx.state === 'suspended') return;
            
            // 1. ËµõÂçöÊúãÂÖãÈáç‰ΩéÈü≥ (Bassline) - 8ÂàÜÈü≥Á¨¶Âæ™ÁéØ
            const bassNotes = [65.41, 65.41, 77.78, 77.78, 87.31, 87.31, 98.00, 98.00]; // C, Eb, F, G
            const bassFreq = bassNotes[Math.floor(step / 2) % 8];
            SFX.playTone(bassFreq, 'sawtooth', 0.2, 0.08);

            // 2. Âä®ÊÑüÈºìÁÇπ (Drums) - 16ÂàÜÈü≥Á¨¶
            if (step % 4 === 0) SFX.playTone(50, 'sine', 0.15, 0.4, 10); // Âº∫Â∫ïÈºì Kick
            if (step % 4 === 2) SFX.playTone(6000, 'square', 0.03, 0.01); // Ë∏©Èï≤ Hi-hat

            // 3. ÁîµÂ≠êÁê∂Èü≥ÊóãÂæã (Melody) - ÁÅµÂä®Ë∑≥Ë∑É
            const melody = [261.63, 0, 311.13, 0, 392.00, 311.13, 0, 0, 349.23, 0, 440.00, 0, 392.00, 0, 0, 0];
            const melFreq = melody[step % 16];
            if (melFreq > 0) SFX.playTone(melFreq * 2, 'square', 0.1, 0.03);

            step++;
        }, 125); // Á∫¶ 120 BPM ÁöÑ 16 ÂàÜÈü≥Á¨¶ÈÄüÂ∫¶
    }

    // Êó†ÊÑüÂî§ÈÜíÈü≥È¢ëÂºïÊìéÔºàÊ†∏ÂøÉÈÄªËæëÔºâ
    function unlockAudio() {
        if (!audioUnlocked) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            audioUnlocked = true;
            if (audioEnabled) startBGM();
        }
    }

    function toggleAudio() {
        unlockAudio(); // ÁÇπÂáªÊåâÈíÆ‰πüËÉΩÂî§ÈÜí
        audioEnabled = !audioEnabled;
        const btn = document.getElementById('audio-toggle');
        if (audioEnabled) {
            btn.innerText = 'üîä Èü≥‰πêÂºÄÂêØ';
            startBGM();
        } else {
            btn.innerText = 'üîá Èü≥‰πêÂÖ≥Èó≠';
            if (bgmTimer) clearInterval(bgmTimer);
        }
    }

    // --- Ê∏∏Êàè‰∏ªÈÄªËæë ---
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next-canvas');
    const nextCtx = nextCanvas.getContext('2d');
    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 30;

    const COLORS = [
        null, '#00ffff', '#0055ff', '#ffaa00', '#ffff00', '#00ff00', '#ff00ff', '#ff0000'
    ];

    const SHAPES = [
        [],
        [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], 
        [[2,0,0],[2,2,2],[0,0,0]],                
        [[0,0,3],[3,3,3],[0,0,0]],                
        [[4,4],[4,4]],                            
        [[0,5,5],[5,5,0],[0,0,0]],                
        [[0,6,0],[6,6,6],[0,0,0]],                
        [[7,7,0],[0,7,7],[0,0,0]]                 
    ];

    const BLESSINGS = ["Êö¥ÂØå!", "ÂèëË¥¢!", "Â§ßÂêâÂ§ßÂà©!", "Â≤ÅÂ≤ÅÂπ≥ÂÆâ!", "Ë¥¢Ê∫êÊªöÊªö!", "Â•ΩËøêËøûËøû!", "Ê±™ÊÄªÁâõÈÄº!", "Ê±™ÂÜõÂèëÂ§ßË¥¢!"];

    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let score = 0;
    let totalLines = 0; 
    let rage = 0;
    const MAX_RAGE = 100;

    let piece = { matrix: [], x: 0, y: 0 };
    let nextPieceId = Math.floor(Math.random() * 7) + 1;
    let dropCounter = 0;
    let dropInterval = 1000; 
    let lastTime = 0;
    let particles = [];

    // ÁªòÂà∂‰∏ã‰∏Ä‰∏™ÊñπÂùóÈ¢ÑÊµã
    function drawNext() {
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        const matrix = SHAPES[nextPieceId];
        const color = COLORS[nextPieceId];
        const bs = 12; 
        const offsetX = (nextCanvas.width - matrix[0].length * bs) / 2;
        const offsetY = (nextCanvas.height - matrix.length * bs) / 2;
        
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    nextCtx.fillStyle = color;
                    nextCtx.fillRect(offsetX + x * bs, offsetY + y * bs, bs, bs);
                    nextCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    nextCtx.fillRect(offsetX + x * bs + 1, offsetY + y * bs + 1, bs - 2, bs - 2);
                    nextCtx.strokeStyle = '#220000';
                    nextCtx.lineWidth = 1;
                    nextCtx.strokeRect(offsetX + x * bs, offsetY + y * bs, bs, bs);
                }
            });
        });
    }

    function createFireworks(yPos) {
        for (let i = 0; i < 40; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: yPos * BLOCK_SIZE + (BLOCK_SIZE / 2),
                vx: (Math.random() - 0.5) * 15, 
                vy: (Math.random() - 1) * 15,   
                life: 1,
                color: Math.random() > 0.4 ? '#ffd700' : '#ff0000'
            });
        }
    }

    function drawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.random() * 3 + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.5; 
            p.life -= 0.03; 
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function showBlessing(yPos) {
        const rect = canvas.getBoundingClientRect();
        const text = document.createElement('div');
        text.className = 'blessing-text';
        text.innerText = BLESSINGS[Math.floor(Math.random() * BLESSINGS.length)];
        const absoluteX = rect.left + (rect.width / 2);
        const absoluteY = rect.top + (yPos * (rect.height / ROWS));
        text.style.left = absoluteX + 'px';
        text.style.top = absoluteY + 'px';
        document.body.appendChild(text);
        setTimeout(() => text.remove(), 1000);
    }

    function resetGame() {
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        score = 0;
        totalLines = 0;
        rage = 0;
        particles = [];
        updateSpeed();
        updateUI();
    }

    function spawnPiece() {
        piece.matrix = SHAPES[nextPieceId];
        piece.y = 0;
        piece.x = Math.floor(COLS / 2) - Math.floor(piece.matrix[0].length / 2);
        
        nextPieceId = Math.floor(Math.random() * 7) + 1;
        drawNext(); 

        if (collide(board, piece)) resetGame(); 
    }

    function drawBlock(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
        ctx.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) drawBlock(x + offset.x, y + offset.y, COLORS[value]);
            });
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMatrix(board, {x: 0, y: 0});
        drawMatrix(piece.matrix, {x: piece.x, y: piece.y});
        drawParticles(); 
    }

    function collide(board, testPiece) {
        const m = testPiece.matrix;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (board[y + testPiece.y] && board[y + testPiece.y][x + testPiece.x]) !== 0) return true;
            }
        }
        return false;
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) board[y + piece.y][x + piece.x] = value;
            });
        });
    }

    function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    }

    function playerMove(dir) {
        unlockAudio();
        piece.x += dir;
        if (collide(board, piece)) {
            piece.x -= dir;
        } else {
            SFX.move();
        }
    }

    function playerDrop() {
        piece.y++;
        if (collide(board, piece)) {
            piece.y--;
            merge(board, piece);
            spawnPiece();
            sweep();
        }
        dropCounter = 0;
    }

    function playerHardDrop() {
        unlockAudio();
        while (!collide(board, piece)) piece.y++;
        piece.y--; 
        SFX.drop();
        merge(board, piece);
        spawnPiece();
        sweep();
        dropCounter = 0;
    }

    function playerRotate(dir) {
        unlockAudio();
        const pos = piece.x;
        let offset = 1;
        rotate(piece.matrix, dir);
        while (collide(board, piece)) {
            piece.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > piece.matrix[0].length) {
                rotate(piece.matrix, -dir);
                piece.x = pos;
                return;
            }
        }
        SFX.rotate();
    }

    function updateSpeed() {
        let speedBoosts = Math.floor(totalLines / 5);
        dropInterval = Math.max(16, 1000 * Math.pow(0.95, speedBoosts));
    }

    function sweep() {
        let rowCount = 1;
        let linesCleared = 0;
        let lowestY = 0; 

        outer: for (let y = ROWS - 1; y >= 0; --y) {
            for (let x = 0; x < COLS; ++x) {
                if (board[y][x] === 0) continue outer;
            }
            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            if (y > lowestY) lowestY = y; 
            ++y;

            let currentMultiplier = (1000 / dropInterval);
            score += Math.floor(rowCount * 88 * currentMultiplier); 
            rowCount *= 2;
            linesCleared++;
        }

        if (linesCleared > 0) {
            totalLines += linesCleared;
            updateSpeed();
            SFX.clear();
            createFireworks(lowestY);
            showBlessing(lowestY);

            rage += linesCleared * 20; 
            if (rage >= MAX_RAGE) {
                rage = MAX_RAGE;
                document.getElementById('rage-container').classList.add('nuke-ready');
            }
            updateUI();
        }
    }

    function triggerNuke() {
        if (rage < MAX_RAGE) return;
        unlockAudio();
        SFX.nuke();
        document.body.classList.add('nuke-flash');
        setTimeout(() => document.body.classList.remove('nuke-flash'), 400);

        for(let i=0; i<ROWS; i+=4) createFireworks(i);
        showBlessing(ROWS/2);
        showBlessing(ROWS/2 - 2);
        showBlessing(ROWS/2 + 2);

        for (let r = 0; r < ROWS; r++) board[r].fill(0);
        let currentMultiplier = (1000 / dropInterval);
        score += Math.floor(8888 * currentMultiplier);
        rage = 0;
        document.getElementById('rage-container').classList.remove('nuke-ready');
        updateUI();
    }

    function updateUI() {
        document.getElementById('score').innerText = score;
        let currentSpeedPct = Math.floor((1000 / dropInterval) * 100);
        document.getElementById('speed-display').innerText = currentSpeedPct + '%';
        
        const rageBar = document.getElementById('rage-bar');
        if (window.innerWidth <= 600) {
            rageBar.style.width = rage + '%';
            rageBar.style.height = '100%';
        } else {
            rageBar.style.height = rage + '%';
            rageBar.style.width = '100%';
        }
    }

    function update(time = 0) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) playerDrop(); 
        
        draw();
        requestAnimationFrame(update);
    }

    document.addEventListener('keydown', event => {
        if ([32, 37, 38, 39, 40].includes(event.keyCode)) {
            event.preventDefault(); // ÈòªÊ≠¢È°µÈù¢ÊªöÂä®
        }
        if (event.keyCode === 37) playerMove(-1);      
        else if (event.keyCode === 39) playerMove(1);  
        else if (event.keyCode === 40) playerHardDrop(); 
        else if (event.keyCode === 38) playerRotate(1);
        else if (event.keyCode === 32) triggerNuke();
    });

    const bindTouch = (id, action) => {
        const btn = document.getElementById(id);
        btn.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            action(); 
        }, {passive: false});
    };
    bindTouch('btn-left', () => playerMove(-1));
    bindTouch('btn-right', () => playerMove(1));
    bindTouch('btn-rotate', () => playerRotate(1));
    bindTouch('btn-down', () => playerHardDrop());

    window.addEventListener('resize', updateUI);
    
    // Ê∏∏ÊàèËá™Âä®Âä†ËΩΩÂπ∂Á≠âÂæÖÁ¨¨‰∏ÄÊ¨°ËæìÂÖ•
    spawnPiece();
    update();
</script>

</body>
</html>
